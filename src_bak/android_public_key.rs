use std::error::Error;
use lazy_static::lazy_static;
use openssl::pkey::{Private, Public};
use openssl::rsa::Padding;
use openssl::sign::Signer;

const ANDROID_PUBKEY_MODULUS_SIZE: i32 = 2048 / 8;
const ANDROID_PUBKEY_ENCODED_SIZE: i32 = 3 * 4 + 2 * ANDROID_PUBKEY_MODULUS_SIZE;
const ANDROID_PUBKEY_MODULUS_SIZE_WORDS: i32 = ANDROID_PUBKEY_MODULUS_SIZE / 4;
const SIGNATURE_PADDING_AS_INT: [i32; 236] = [0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00,
    0x30, 0x21, 0x30, 0x09, 0x06, 0x05, 0x2b, 0x0e, 0x03, 0x02, 0x1a, 0x05, 0x00,
    0x04, 0x14];

lazy_static! {
    static ref RSA_SHA_PKCS1_SIGNATURE_PADDING: Vec<u8> = {
        let mut rsa_sha_pkcs1_signature_padding: Vec<u8> = Vec::new();
        for i in SIGNATURE_PADDING_AS_INT.iter() {
            rsa_sha_pkcs1_signature_padding.push(*i as u8);
        }
        rsa_sha_pkcs1_signature_padding
    };
}

pub fn test() -> () {
    //a: Vec<u8> = Vec::new()
}

pub struct AndroidPublicKey {}

impl AndroidPublicKey {
    fn adb_auth_sign(private_key: &Private, payload: &[u8]) -> Result<Vec<u8>, Box<dyn Error>> {
        let padding = Padding::PKCS1_SHA1;
        let mut signer = Signer::new(padding, &private_key)?;
        signer.update(payload)?;
        let signature = signer.sign_to_vec()?;
        Ok(signature)
    }

    fn encode_with_name(public_key: &Public, name: &str) -> Result<Vec<u8>, Box<dyn Error>> {
        let pkey_size = 4 * (((ANDROID_PUBKEY_ENCODED_SIZE / 3.0) as f32).ceil() as usize);
        let mut buffer = vec![0; pkey_size + name.len() + 2];

        let mut cursor = Cursor::new(&mut buffer[..]);
        let pubkey_encoded = encode(encode(public_key.to_der()?)?);
        cursor.write_all(pubkey_encoded.as_bytes())?;

        let user_info = get_user_info(name);
        cursor.write_all(user_info.as_bytes())?;

        Ok(cursor.into_inner())
    }

    fn get_user_info(name: &str) -> String {
        let mut user_info = String::with_capacity(name.len() + 2);
        user_info.push_str(name);
        user_info.push_str("\n");
        user_info
    }
}

